# 복잡도 이론

알고리즘을 풀 때 반드시 알아둬야 할 기본지식 중 하나

# 시간 복잡도

제한시간이 있는 문제일때, 시간안에 풀 수 있을지 가늠할 때 필요한 개념

<aside>
❓ N을 입력받아 1~N 의 합계를 출력하시오

</aside>

```
1 + 2 + 3 ••• + N 
```

덧셈 연산을 대략 N번 하게 됨

→ N이 커지면 비례해서 연산 수도 늘어난다

```
( N * ( N + 1 ) ) / 2 
```

N이 몇이든 사칙연산을 세번만 수행하면 됨

→ **문제를 푸는 알고리즘은 여러가지가 존재할 수 있으며, 속도도 다르다 !**

## 빅-오 표기법

복잡도를 나타내는 방법

입력범위 N에 비례해 연산 횟수가 늘어나는 정도를 나타내는 것

```
1 + 2 + 3 ••• + N 
```

```
( N * ( N + 1 ) ) / 2 
```

1 번의 방법은? → O(N)

2 번의 방법은? → O(1)

### 표기 방법

가장 큰 항만 남기고 작은 항들과 계수는 전부 생략 가능

```
3N² + 10N + 700
```

시간복잡도는 ? O(N²)

→ N이 20배 증가하면 연산 수는 약 400배 증가

## 항상 시간복잡도를 신경써야 할까?

<aside>
❓ 1 ~ N 의 합계를 출력하세요 [제한시간 1초]

</aside>

**N의 범위가 10,000 라면 ?**

→ O(N), O(1) 모두 가능

**N의 범위가 2,000,000,000 라면 ?**

→ O(N) 는 시간초과의 가능성이 있음

→ O(1) 의 방법을 찾아야 한다 !

## 자료구조별 시간복잡도

![image](https://github.com/minmunlee/algorithm-study/assets/105481797/953c0bea-8919-43aa-9f3c-de1ad6edd268)

# 공간 복잡도

문제의 메모리 제한을 넘기지 않고 프로그램이 돌아갈 지 판달할 때 필요한 개념

크기 2000 짜리 int 배열 → 4 * 2,000 byte = 2,000byte = 8KB 

메모리 제한은 보통 128~512MB 로 주어지는 경우가 많다 → int 기준 3천만 이상 할당하면 위험 !

> 배열 크기가 천만이 넘어가면 잘못된 알고리즘이 아닌가 의심해보세요
> 

## 정렬 알고리즘별 시간 및 공간 복잡도

![image](https://github.com/minmunlee/algorithm-study/assets/105481797/92e00df1-db3b-4fe4-9378-0b35a8e5c87f)

# 알고리즘을 잘 선택해 시간과 메모리 제한을 지키며 문제를 해결해보자 !!

참고

[https://www.yes24.com/Product/Search?query=취업코딩테스트](https://www.yes24.com/Product/Search?query=%EC%B7%A8%EC%97%85%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8)

https://velog.io/@welloff_jj/Complexity-and-Big-O-notation